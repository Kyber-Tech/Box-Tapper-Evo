# Box tapper: Evo
import pygame
import random
import math
import os
import time
import json

# INITIALIZATION
pygame.init()
pygame.mixer.init()

# SETTINGS & CONSTANTS
WIDTH, HEIGHT = 1280, 720
FPS = 60

# --- Display Setup ---
os.environ['SDL_VIDEO_CENTERED'] = '1'
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
pygame.display.set_caption("Box Tapper: Evolution V.1.8.0")
clock = pygame.time.Clock()

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (150, 150, 150)
DARK_GRAY = (50, 50, 50)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)
NEBULA_BLUE = (50, 50, 200)
NEBULA_PURPLE = (150, 50, 200)
GALAXY_INDIGO = (75, 0, 130)
STARLIGHT_CYAN = (100, 200, 255)
COSMIC_MAGENTA = (200, 50, 200)
AURORA_GREEN = (50, 200, 150)

# --- Fonts ---
font = pygame.font.Font(None, 36)
big_font = pygame.font.Font(None, 72)
button_font = pygame.font.Font(None, 48)
tutorial_font = pygame.font.Font(None, 42)
stats_font = pygame.font.Font(None, 48)

# --- Game Mechanics ---
BASE_BOX_HEALTH = 1
BOSS_HEALTH_MULTIPLIER = 2
MAX_HIGH_SCORES = 5
MAX_LEVEL_CLASSIC = 100
ASTEROID_START_LEVEL = 30

# --- Cheat Codes---
CHEAT_SEQUENCES = {
    "INVINCIBILITY": ["hit_box", "hit_empty", "hit_box", "hit_box", "hit_empty", "hit_empty", "hit_box", "hit_box", "hit_empty"],
    "INSTANT_KILL": ["hit_box", "hit_box", "hit_empty", "hit_empty", "hit_box", "hit_box", "hit_box", "hit_empty", "hit_empty", "hit_box"],
    "DOUBLE_SCORE": ["hit_empty", "hit_box", "hit_empty", "hit_empty", "hit_box"],
    "LEVEL_SKIP": ["hit_empty", "hit_empty", "hit_box", "hit_box", "hit_empty", "hit_box", "hit_box"],
    "HUD_TOGGLE": ["hit_empty", "hit_empty", "hit_box", "hit_box", "hit_empty", "hit_empty", "hit_empty", "hit_box", "hit_box", "hit_empty"],
    "DEBUG_MODE": ["hit_box", "hit_empty", "hit_empty", "hit_box", "hit_empty","hit_box", "hit_empty", "hit_empty", "hit_box", "hit_empty"]
}

# --- Asset Storage ---
SPRITES = {}
LOADED_ASSETS = {"total": 0, "loaded": 0}

# --- ASSET LOADING FUNCTIONS ---
def update_loading_screen(message):
    """Draws the loading screen with a progress bar."""
    global WIDTH, HEIGHT
    screen.fill(BLACK)
    
    title_surf = big_font.render("Loading Game...", True, WHITE)
    screen.blit(title_surf, title_surf.get_rect(center=(WIDTH//2, HEIGHT//3)))
    
    msg_surf = font.render(message, True, GRAY)
    screen.blit(msg_surf, msg_surf.get_rect(center=(WIDTH//2, HEIGHT//2)))
    
    if LOADED_ASSETS["total"] > 0:
        progress = LOADED_ASSETS["loaded"] / LOADED_ASSETS["total"]
        bar_width, bar_height = 400, 30
        fill_width = int(bar_width * progress)
        bar_rect = pygame.Rect((WIDTH - bar_width)//2, HEIGHT*2/3, bar_width, bar_height)
        fill_rect = pygame.Rect((WIDTH - bar_width)//2, HEIGHT*2/3, fill_width, bar_height)
        pygame.draw.rect(screen, DARK_GRAY, bar_rect)
        pygame.draw.rect(screen, STARLIGHT_CYAN, fill_rect)
        pygame.draw.rect(screen, WHITE, bar_rect, 2)
        
    pygame.display.flip()

def load_sprite(name, filename):
    """Loads a single sprite and handles errors gracefully."""
    LOADED_ASSETS["total"] += 1
    message = f"Loading: {filename}"
    print(message)
    update_loading_screen(message)
    try:
        SPRITES[name] = pygame.image.load(filename).convert_alpha()
    except pygame.error:
        print(f"Warning: Could not load '{filename}'. Game will use a fallback shape.")
        SPRITES[name] = None
    LOADED_ASSETS["loaded"] += 1
    update_loading_screen(message)

def load_all_assets():
    """Loads all game images and sounds."""
    global music_loaded
    assets_to_load = {
        "background": "background.png",
        "background_foreground": "background_foreground.png", # NEW animated layer
        "box": "box.png",
        "boss": "boss.png",
        "circle": "circle.png",
        "asteroid": "asteroid.png",
        "star": "star.png",
        "snail": "snail.png",
        "nyan_cat": "nyan_cat.png",
        "button_idle": "button_idle.png",
        "button_hover": "button_hover.png",
        "powerup_shield": "powerup_shield.png",
        "powerup_speed": "powerup_speed.png",
        "powerup_cosmic": "powerup_cosmic.png",
        "powerup_multi_tap": "powerup_multi_tap.png",
        "powerup_black_hole": "powerup_black_hole.png",
        "powerup_time_warp": "powerup_time_warp.png",
        "powerup_nyan": "powerup_nyan.png",
        "powerup_freeze": "powerup_freeze.png"
    }
    for name, filename in assets_to_load.items():
        load_sprite(name, filename)

    music_loaded = False
    LOADED_ASSETS["total"] += 1
    update_loading_screen("Loading: background_music.wav")
    try:
        pygame.mixer.music.load("background_music.wav")
        music_loaded = True
        print("Music file 'background_music.wav' loaded successfully.")
    except pygame.error as e:
        print(f"Warning: Could not load 'background_music.wav'. Error: {e}")
    LOADED_ASSETS["loaded"] += 1
    update_loading_screen("Loading complete!")
    time.sleep(0.5)

# --- Difficulty Settings ---
DIFFICULTY_SETTINGS = {
    "easy":       {"lives": 100, "health_mod": 0.1, "speed_mod": 0.7, "spawn_mod": 0.5, "asteroid_mod": 0.1, "score_mod": 0.0, "dust_mod": 1.5},
    "beginner":   {"lives": 30, "health_mod": 0.8, "speed_mod": 0.9, "spawn_mod": 0.9, "asteroid_mod": 0.8, "score_mod": 0.75,  "dust_mod": 1.2},
    "casual":     {"lives": 10, "health_mod": 1.0, "speed_mod": 1.0, "spawn_mod": 1.0, "asteroid_mod": 1.0, "score_mod": 1.0,  "dust_mod": 1.0},
    "hardcore":   {"lives": 5,  "health_mod": 1.5, "speed_mod": 1.2, "spawn_mod": 1.2, "asteroid_mod": 1.3, "score_mod": 1.25, "dust_mod": 1.25},
    "insane":     {"lives": 3,  "health_mod": 2.0, "speed_mod": 1.5, "spawn_mod": 1.5, "asteroid_mod": 2.0, "score_mod": 2.0,  "dust_mod": 1.5},
    "demon":      {"lives": 1,  "health_mod": 3.0, "speed_mod": 2.0, "spawn_mod": 2.0, "asteroid_mod": 2.0, "score_mod": 20.0,  "dust_mod": 2.0},
}

DRAMATIC_QUOTES = ["Et tu, Brute?", "I'm melting!", "I am just in a Game!", "Rosebud...", "Tell my story!", "What's in the box?!", "I've seen things...", "Who am I? who created this?", "Farewell, cruel world!"]

# CLASSES
class Tool:
    def __init__(self, id, level, damage, score_multiplier, is_dev):
        self.id, self.level, self.damage, self.score_multiplier, self.is_dev = id, level, damage, score_multiplier, is_dev

class Star:
    def __init__(self):
        self.x, self.y = random.randint(0, WIDTH), random.randint(0, HEIGHT)
        self.radius = random.randint(1, 3)
        self.color, self.alpha = WHITE, random.randint(50, 255)
        self.fade_speed = random.uniform(0.5, 2.0)

    def update(self):
        self.alpha += self.fade_speed
        if self.alpha >= 255 or self.alpha <= 50: self.fade_speed *= -1
        self.alpha = max(50, min(255, self.alpha))

    def draw(self, surface):
        sprite = SPRITES.get("star")
        if sprite:
            temp_sprite = sprite.copy()
            scaled_sprite = pygame.transform.scale(temp_sprite, (self.radius * 2, self.radius * 2))
            scaled_sprite.set_alpha(int(self.alpha))
            surface.blit(scaled_sprite, (self.x - self.radius, self.y - self.radius))
        else:
            star_surf = pygame.Surface((self.radius * 2, self.radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(star_surf, (*self.color, int(self.alpha)), (self.radius, self.radius), self.radius)
            surface.blit(star_surf, (self.x - self.radius, self.y - self.radius))

class Nebula:
    def __init__(self):
        self.x, self.y = random.randint(0, WIDTH), random.randint(0, HEIGHT)
        self.radius = random.randint(100, 300)
        self.color = random.choice([NEBULA_BLUE, NEBULA_PURPLE, STARLIGHT_CYAN])
        self.alpha, self.pulse_speed = random.randint(20, 50), random.uniform(0.1, 0.5)

    def update(self):
        self.alpha += self.pulse_speed
        if self.alpha >= 50 or self.alpha <= 20: self.pulse_speed *= -1
        self.alpha = max(20, min(50, self.alpha))

    def draw(self, surface):
        nebula_surf = pygame.Surface((self.radius * 2, self.radius * 2), pygame.SRCALPHA)
        for r in range(int(self.radius), 0, -1):
            alpha = int(self.alpha * (r / self.radius))
            pygame.draw.circle(nebula_surf, (*self.color, alpha), (self.radius, self.radius), r)
        surface.blit(nebula_surf, (self.x - self.radius, self.y - self.radius))

class Particle:
    def __init__(self, x, y, color):
        self.x, self.y, self.color = x, y, color
        self.vx, self.vy = random.uniform(-3, 3), random.uniform(-3, 3)
        self.lifespan, self.radius = random.randint(20, 40), random.randint(2, 5)

    def update(self):
        self.x, self.y = self.x + self.vx, self.y + self.vy
        self.lifespan, self.radius = self.lifespan - 1, self.radius - 0.1
        return self.lifespan > 0 and self.radius > 0

    def draw(self, surface):
        if self.radius > 0: pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), int(self.radius))

class Asteroid:
    def __init__(self, is_meteor=False):
        if is_meteor:
            self.x, self.y = random.randint(0, WIDTH), -20
            self.vx, self.vy = random.uniform(-1, 1), random.uniform(8, 12)
        else:
            start_side = random.choice(['left', 'right', 'top', 'bottom'])
            if start_side == 'left': self.x, self.y, self.vx, self.vy = -20, random.randint(0, HEIGHT), random.uniform(2, 4), random.uniform(-1, 1)
            elif start_side == 'right': self.x, self.y, self.vx, self.vy = WIDTH + 20, random.randint(0, HEIGHT), random.uniform(-4, -2), random.uniform(-1, 1)
            elif start_side == 'top': self.x, self.y, self.vx, self.vy = random.randint(0, WIDTH), -20, random.uniform(-1, 1), random.uniform(2, 4)
            else: self.x, self.y, self.vx, self.vy = random.randint(0, WIDTH), HEIGHT + 20, random.uniform(-1, 1), random.uniform(-4, -2)
        self.radius = random.randint(10, 25)
        self.rect = pygame.Rect(self.x-self.radius, self.y-self.radius, self.radius*2, self.radius*2)
        self.angle, self.rotation_speed = 0, random.uniform(-2, 2)

    def move(self):
        self.x, self.y = self.x + self.vx, self.y + self.vy
        self.rect.center, self.angle = (self.x, self.y), self.angle + self.rotation_speed

    def is_offscreen(self): return self.rect.right<0 or self.rect.left>WIDTH or self.rect.bottom<0 or self.rect.top>HEIGHT

    def draw(self, surface):
        sprite = SPRITES.get("asteroid")
        if sprite:
            scaled = pygame.transform.scale(sprite, (self.rect.width, self.rect.height))
            rotated = pygame.transform.rotate(scaled, self.angle)
            surface.blit(rotated, rotated.get_rect(center=self.rect.center))
        else:
            pygame.draw.circle(surface, DARK_GRAY, self.rect.center, self.radius)
            pygame.draw.circle(surface, GRAY, self.rect.center, self.radius, 2)

class BlackHole:
    def __init__(self, x, y):
        self.x, self.y = x, y
        self.radius, self.max_radius, self.pull_radius = 10, 80, 300
        self.pull_force, self.grow_speed, self.lifespan = 1.5, 0.5, 5
        self.start_time = time.time()

    def update(self, boxes):
        if self.radius < self.max_radius: self.radius += self.grow_speed
        for box in boxes[:]:
            dist_x, dist_y = self.x - box.rect.centerx, self.y - box.rect.centery
            distance = math.hypot(dist_x, dist_y)
            if distance < self.pull_radius:
                if distance < self.radius: damage_box(box, is_black_hole=True)
                else:
                    angle = math.atan2(dist_y, dist_x)
                    box.rect.x += self.pull_force * math.cos(angle)
                    box.rect.y += self.pull_force * math.sin(angle)
        return time.time() - self.start_time < self.lifespan

    def draw(self, surface):
        pygame.draw.circle(surface, BLACK, (self.x, self.y), int(self.radius))
        for i in range(3):
            angle = (time.time() * (i+1) * 2) % (2 * math.pi)
            p_radius = self.radius + 10 + i * 5
            px, py = self.x + p_radius * math.cos(angle), self.y + p_radius * math.sin(angle)
            pygame.draw.circle(surface, NEBULA_PURPLE, (int(px), int(py)), 3)

class Snail:
    def __init__(self):
        self.x, self.y, self.speed = -30, random.randint(HEIGHT - 100, HEIGHT - 50), 0.5
        self.rect = pygame.Rect(self.x, self.y, 60, 30)

    def update(self): self.x += self.speed; self.rect.x = self.x

    def draw(self, surface):
        sprite = SPRITES.get("snail")
        if sprite: surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else: pygame.draw.rect(surface, GOLD, self.rect)

class NyanCat:
    def __init__(self):
        self.y, self.x, self.speed = random.randint(50, HEIGHT - 50), -100, 10
        self.rect = pygame.Rect(self.x, self.y, 80, 50)
        self.trail = []

    def update(self, boxes):
        self.x += self.speed; self.rect.x = self.x
        trail_part = self.rect.copy(); trail_part.width = 20
        self.trail.append(trail_part)
        if len(self.trail) > 30: self.trail.pop(0)
        for box in boxes:
            if self.rect.colliderect(box.rect) and box.special_type != "rainbow":
                box.special_type = "rainbow"
                box.color = (random.randint(100,255), random.randint(100,255), random.randint(100,255))
        return self.x < WIDTH + 100

    def draw(self, surface):
        colors = [RED, (255, 165, 0), YELLOW, GREEN, (0, 0, 255), (75, 0, 130), (238, 130, 238)]
        for i, r in enumerate(self.trail): pygame.draw.rect(surface, colors[i % len(colors)], r)
        sprite = SPRITES.get("nyan_cat")
        if sprite: surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else: pygame.draw.rect(surface, COSMIC_MAGENTA, self.rect)

class Box:
    def __init__(self, x, y, w, h, color, health, is_child=False):
        self.rect = pygame.Rect(int(x), int(y), w, h)
        self.color, self.health, self.max_health = color, health, health
        speed_mod = DIFFICULTY_SETTINGS.get(gs.get("difficulty"), {}).get("speed_mod", 1.0)
        self.speed = (5 * speed_mod) * (1.5 if is_child else 1.0)
        self.direction = random.choice([-1, 1])
        self.special_type, self.alpha = None, 255
        self.is_shrinking, self.shrink_rate, self.min_size = False, 0.25, 20
        self.is_dying, self.death_timer, self.death_quote = False, 0, ""
        self.teleport_timer = time.time() + random.uniform(2, 4)
        self.visible_timer = time.time() + random.uniform(1, 3)
        self.is_child = is_child
        self.gravity_strength = 0.0
        if not is_child: self.assign_special_type()

    def assign_special_type(self):
        roll = random.random()
        if roll < 0.02: self.special_type, self.color, self.health, self.speed = "golden", GOLD, 3, 8
        elif roll < 0.25:
            choices = ["explosive", "regen", "shrinking", "multi", "splitter", "gravity"]
            if gs.get("game_mode") == "chaos": choices.extend(["dramatic", "teleporter"])
            self.special_type = random.choice(choices)
            if self.special_type == "splitter": self.color = GREEN
            if self.special_type == "dramatic": self.color = WHITE
            if self.special_type == "teleporter": self.color = STARLIGHT_CYAN
            if self.special_type == "shrinking": self.is_shrinking = True
            if self.special_type == "multi": self.taps_required = min(1 + gs["level"] // 10, 5); self.tap_count, self.tap_timer = 0, 0
            if self.special_type == "gravity": self.color, self.gravity_strength = NEBULA_PURPLE, 1.0

    def update(self):
        if self.is_dying:
            if time.time() > self.death_timer: self.health = 0
            return
        if gs["game_mode"] == "stealth":
            if time.time() > self.visible_timer:
                if self.alpha < 255: self.alpha = 255
                elif self.alpha == 255: self.alpha, self.visible_timer = 10, time.time() + random.uniform(2, 5)
            elif self.alpha == 255: self.alpha = 10
        if self.special_type == "teleporter" and time.time() > self.teleport_timer:
            self.rect.x, self.rect.y = random.randint(0, WIDTH - self.rect.width), random.randint(0, HEIGHT - self.rect.height)
            self.teleport_timer = time.time() + random.uniform(1, 3)
        self.rect.x += self.speed * self.direction
        if self.rect.left <= 0 or self.rect.right >= WIDTH: self.direction *= -1
        if self.special_type == "regen" and self.health < self.max_health: self.health = min(self.health + 0.5/FPS, self.max_health)
        if self.is_shrinking and self.rect.width > self.min_size:
            center = self.rect.center
            self.rect.width, self.rect.height = max(self.min_size, self.rect.width - self.shrink_rate), max(self.min_size, self.rect.height - self.shrink_rate)
            self.rect.center = center
        if self.special_type == "gravity":
            for other in gs["boxes"]:
                if other != self and not other.is_dying:
                    dist_x, dist_y = self.rect.centerx - other.rect.centerx, self.rect.centery - other.rect.centery
                    distance = math.hypot(dist_x, dist_y)
                    if 0 < distance < 200:
                        angle = math.atan2(dist_y, dist_x)
                        other.rect.x += self.gravity_strength * math.cos(angle)
                        other.rect.y += self.gravity_strength * math.sin(angle)

    def draw(self, surface):
        sprite = SPRITES.get("box")
        if sprite:
            temp_surf = pygame.transform.scale(sprite, self.rect.size).copy()
            temp_surf.set_alpha(int(self.alpha))
            surface.blit(temp_surf, self.rect.topleft)
        else:
            box_surf = pygame.Surface(self.rect.size, pygame.SRCALPHA)
            box_surf.fill((*self.color, int(self.alpha)))
            surface.blit(box_surf, self.rect.topleft)
        if self.max_health > 1:
            h_ratio = self.health / self.max_health
            bar_w = self.rect.width * h_ratio
            pygame.draw.rect(surface, AURORA_GREEN, (self.rect.x, self.rect.y - 10, bar_w, 5))
            pygame.draw.rect(surface, BLACK, (self.rect.x, self.rect.y - 10, self.rect.width, 5), 1)
        if self.special_type == "multi":
            text = font.render(f"{self.tap_count}/{self.taps_required}", True, BLACK)
            surface.blit(text, text.get_rect(center=self.rect.center))
        if self.is_dying:
            quote = font.render(self.death_quote, True, WHITE)
            surface.blit(quote, quote.get_rect(midbottom=self.rect.midtop))
        if self.special_type == "gravity":
            radius = 50 + 10 * math.sin(time.time() * 2)
            pygame.draw.circle(surface, (*NEBULA_PURPLE, 80), self.rect.center, int(radius), 2)

class Boss(Box):
    def __init__(self, x, y, w, h, color, health):
        super().__init__(x, y, w, h, color, health)
        self.dodge_chance, self.phase, self.minions = 0.3, 1, []

    def update(self):
        super().update()
        for minion in self.minions[:]:
            minion.update()
            if minion.health <= 0: self.minions.remove(minion)

    def update_phase(self):
        h_ratio = self.health / self.max_health
        if h_ratio <= 0.5 and self.phase == 1: self.phase, self.color, self.dodge_chance = 2, RED, 0.6
        elif h_ratio <= 0.25 and self.phase == 2:
            self.phase, self.speed = 3, self.speed * 2
            for _ in range(3):
                size = (int(self.rect.width*0.7), int(self.rect.height*0.7))
                minion = Box(self.rect.centerx, self.rect.centery, *size, NEBULA_PURPLE, 1)
                minion.speed = 3
                self.minions.append(minion)
    
    def draw(self, surface):
        sprite = SPRITES.get("boss")
        if sprite: surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else: super().draw(surface)
        if self.max_health > 1:
            h_ratio = self.health / self.max_health
            bar_w = self.rect.width * h_ratio
            pygame.draw.rect(surface, AURORA_GREEN, (self.rect.x, self.rect.y - 10, bar_w, 5))
            pygame.draw.rect(surface, BLACK, (self.rect.x, self.rect.y - 10, self.rect.width, 5), 1)

class Circle(Box):
    def __init__(self, x, y, radius, speed):
        super().__init__(x-radius, y-radius, radius*2, radius*2, YELLOW, 1)
        self.radius, self.speed = radius, speed
        self.direction_x, self.direction_y = random.choice([-1, 1]), random.choice([-1, 1])

    def update(self):
        self.rect.x += self.speed * self.direction_x
        self.rect.y += self.speed * self.direction_y
        if self.rect.left<=0 or self.rect.right>=WIDTH: self.direction_x *= -1
        if self.rect.top<=0 or self.rect.bottom>=HEIGHT: self.direction_y *= -1

    def draw(self, surface):
        sprite = SPRITES.get("circle")
        if sprite: surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else: pygame.draw.circle(surface, self.color, self.rect.center, self.radius)

class PowerUp:
    def __init__(self, x, y, type):
        self.rect = pygame.Rect(x, y, 40, 40)
        self.type = type
        self.color = {"cosmic":NEBULA_PURPLE, "multi_tap":AURORA_GREEN, "black_hole":DARK_GRAY, "nyan":GRAY, "time_warp":STARLIGHT_CYAN}.get(type, YELLOW)
        self.vortex_angle = 0

    def draw(self, surface):
        sprite = SPRITES.get(f"powerup_{self.type}")
        if sprite: surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else:
            pygame.draw.rect(surface, self.color, self.rect)
            char = {"cosmic":"C", "multi_tap":"M", "black_hole":"B", "speed":"S", "nyan":"N", "time_warp":"T"}.get(self.type, self.type[0].upper())
            text = font.render(char, True, WHITE)
            surface.blit(text, text.get_rect(center=self.rect.center))
        if self.type == "time_warp":
            for i in range(3):
                angle = (self.vortex_angle + i * 120) % 360; rad = math.radians(angle)
                px, py = self.rect.centerx + 20*math.cos(rad), self.rect.centery + 20*math.sin(rad)
                pygame.draw.circle(surface, WHITE, (int(px), int(py)), 3)
            self.vortex_angle = (self.vortex_angle + 2) % 360

class Button:
    def __init__(self, x, y, w, h, text, color, text_color, hover_color=None):
        self.rect = pygame.Rect(x, y, w, h)
        self.text, self.color, self.text_color, self.hover_color = text, color, text_color, hover_color or color

    def draw(self, surface, is_hovered=False):
        sprite_idle, sprite_hover = SPRITES.get("button_idle"), SPRITES.get("button_hover")
        if sprite_idle:
            sprite = sprite_hover if is_hovered and sprite_hover else sprite_idle
            surface.blit(pygame.transform.scale(sprite, self.rect.size), self.rect.topleft)
        else:
            if is_hovered: pygame.draw.rect(surface, DARK_GRAY, self.rect.inflate(8, 8), border_radius=12)
            pygame.draw.rect(surface, self.hover_color if is_hovered else self.color, self.rect, border_radius=8)
        text_surf = button_font.render(self.text, True, self.text_color)
        surface.blit(text_surf, text_surf.get_rect(center=self.rect.center))

    def is_clicked(self, pos): return self.rect.collidepoint(pos)

def setup_game_variables(difficulty="casual", game_mode="classic"):
    lives = DIFFICULTY_SETTINGS.get(difficulty, {}).get("lives", 10)
    state = {
        "game_state": "main_menu", "game_mode": game_mode, "difficulty": difficulty, "level": 1, "lives": lives, "max_lives": lives, "score": 0, "score_multiplier": 1, 
        "boxes": [], "stars": [], "asteroids": [], "boss": None, "circle": None, "power_up": None, "power_up_active": None, "power_up_timer": 0, "last_boss_speed": 5, 
        "combo": 0, "combo_timer": 0, "hud_active": True, "debug_mode": False, "player_sequence": [], "active_cheats": set(), "cursor_pos": [WIDTH//2, HEIGHT//2], 
        "high_scores": load_high_scores(), "box_colors": [NEBULA_BLUE, NEBULA_PURPLE, GALAXY_INDIGO, STARLIGHT_CYAN, COSMIC_MAGENTA, AURORA_GREEN, RED], "particles": [], 
        "cosmic_dust": 0, "screen_shake": 0, "level_clear_timer": 0, "active_black_hole": None, "upgrades": {"damage": 0, "lives": 0, "dust_bonus": 0, "powerup_time": 0}, 
        "tutorial_stage": 0, "tutorial_objects": [], "tutorial_text": "", "stats": load_stats(), "meteor_shower_warning": 0, "meteor_shower_active": 0, 
        "meteor_event_timer": time.time() + 30, "chaos_event_timer": time.time() + 15, "screen_flipped": False, "snail": None, "nyan_cat": None, "nebulae": [], 
        "achievements": {
            "tap_100_boxes": {"unlocked": False, "condition": lambda s: s["boxes_tapped"] >= 100, "reward": 50, "description": "Tap 100 Boxes"}, 
            "collect_10_powerups": {"unlocked": False, "condition": lambda s: s["powerups_collected"] >= 10, "reward": 100, "description": "Collect 10 Power-ups"}, 
            "defeat_5_bosses": {"unlocked": False, "condition": lambda s: s["bosses_defeated"] >= 5, "reward": 200, "description": "Defeat 5 Bosses"}, 
            "score_10000": {"unlocked": False, "condition": lambda s: s["total_score"] >= 10000, "reward": 150, "description": "Score 10,000 Points"}
        },
        # NEW variables for animated background
        "bg_x": 0, "bg_speed": 0.2, 
        "bg_fg_x": 0, "bg_fg_speed": 0.5
    }
    state["basic_tapper"] = Tool("basic", 1, 1, 1, False)
    state["cheat_tapper"] = Tool("cheat", 99, 999999, 1000, True)
    state["equipped_tool"] = state["basic_tapper"]
    return state

def load_high_scores():
    try:
        with open("highscores.txt", "r") as f: return [int(l.strip()) for l in f if l.strip().isdigit()][:MAX_HIGH_SCORES]
    except FileNotFoundError: return [0] * MAX_HIGH_SCORES

def save_high_scores():
    gs["high_scores"].append(int(gs["score"]))
    gs["high_scores"] = sorted(list(set(gs["high_scores"])), reverse=True)[:MAX_HIGH_SCORES]
    with open("highscores.txt", "w") as f:
        for hs in gs["high_scores"]: f.write(f"{hs}\n")

def load_stats():
    try:
        with open("stats.json", "r") as f: return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError): return {"boxes_tapped": 0, "powerups_collected": 0, "snails_harmed": 0, "total_score": 0, "bosses_defeated": 0}

def save_stats():
    with open("stats.json", "w") as f: json.dump(gs["stats"], f, indent=4)
    for name, ach in gs["achievements"].items():
        if not ach["unlocked"] and ach["condition"](gs["stats"]):
            ach["unlocked"], gs["cosmic_dust"] = True, gs["cosmic_dust"] + ach["reward"]
            print(f"Achievement Unlocked: {ach['description']} (+{ach['reward']} Dust)")

def start_new_level():
    gs["game_state"] = "playing"
    if gs["game_mode"] == "classic" and gs["level"] > MAX_LEVEL_CLASSIC: gs["game_state"] = "victory"; return
    gs["boxes"], gs["boss"], gs["circle"], gs["asteroids"], gs["snail"] = [], None, None, [], None
    gs["meteor_shower_warning"], gs["meteor_shower_active"] = 0, 0
    if gs["game_mode"] == "boss_rush": spawn_boss()
    elif gs["level"] % 10 == 0: spawn_circle()
    elif gs["level"] % 5 == 0: spawn_boss()
    else: spawn_boxes()
    spawn_power_up()
    if not gs["stars"]: spawn_stars()

def create_explosion(x, y, color):
    for _ in range(10): gs["particles"].append(Particle(x, y, color))

def trigger_screen_shake(intensity=10, duration=15): gs["screen_shake"], gs["shake_intensity"] = duration, intensity

def spawn_boxes():
    spawn_mod = DIFFICULTY_SETTINGS[gs["difficulty"]]["spawn_mod"] * (3 if gs["game_mode"] == "chaos" else 1)
    for _ in range(int((5 + gs["level"] // 10) * spawn_mod)):
        size = random.randint(50, 100)
        x, y = random.randint(0, WIDTH - size), random.randint(0, HEIGHT - size)
        color = random.choice(gs["box_colors"])
        health = BASE_BOX_HEALTH * DIFFICULTY_SETTINGS[gs["difficulty"]]["health_mod"]
        gs["boxes"].append(Box(x, y, size, size, color, health))

def spawn_boss():
    level, base_size = gs["level"], 200
    size_mult = max(0.25, 1 - 0.15 * (level // 5)) if level < 50 else 0.1 + 0.10 * ((level - 50) // 5)
    size = (min(int(base_size * size_mult), WIDTH - 20), min(int(base_size * size_mult), HEIGHT - 20))
    pos = (WIDTH//2 - size[0]//2, HEIGHT//2 - size[1]//2)
    health = (BASE_BOX_HEALTH * (BOSS_HEALTH_MULTIPLIER ** (level//5))) * DIFFICULTY_SETTINGS[gs["difficulty"]]["health_mod"]
    gs["boss"] = Boss(*pos, *size, NEBULA_PURPLE, health)
    gs["last_boss_speed"] = gs["boss"].speed

def spawn_circle(): gs["circle"] = Circle(WIDTH//2, HEIGHT//2, 40, gs["last_boss_speed"])

def spawn_power_up():
    if random.random() < 0.2:
        x, y = random.randint(0, WIDTH - 40), random.randint(0, HEIGHT - 40)
        types = ["speed", "shield", "freeze", "cosmic", "multi_tap", "black_hole", "time_warp"]
        if gs["game_mode"] == "chaos": types.append("nyan")
        gs["power_up"] = PowerUp(x, y, random.choice(types))

def spawn_stars():
    gs["stars"] = [Star() for _ in range(100)]
    gs["nebulae"] = [Nebula() for _ in range(3)]

def spawn_asteroid():
    asteroid_chance = 0.02 * DIFFICULTY_SETTINGS[gs["difficulty"]]["asteroid_mod"]
    if gs["level"] >= ASTEROID_START_LEVEL and len(gs["asteroids"]) < (gs["level"] // 10) and random.random() < asteroid_chance:
        gs["asteroids"].append(Asteroid())

def activate_cheat(name):
    if name == "INVINCIBILITY": gs["active_cheats"].add(name)
    elif name == "INSTANT_KILL": gs["active_cheats"].add(name)
    elif name == "DOUBLE_SCORE": gs["active_cheats"].add(name); gs["score_multiplier"] = 2
    elif name == "LEVEL_SKIP": gs["level"] += 1; start_new_level()
    elif name == "HUD_TOGGLE": gs["hud_active"] = not gs["hud_active"]
    elif name == "DEBUG_MODE":
        gs["debug_mode"] = not gs["debug_mode"]
        gs["equipped_tool"] = gs["cheat_tapper"] if gs["debug_mode"] else gs["basic_tapper"]
    print(f"Cheat Activated: {name}")

def start_tutorial():
    gs["game_state"], gs["tutorial_stage"], gs["tutorial_objects"] = "tutorial", 0, []
    gs["tutorial_text"] = "Welcome! Click the stationary box to destroy it."
    box = Box(WIDTH//2-50, HEIGHT//2-50, 100, 100, STARLIGHT_CYAN, 1); box.speed=0
    gs["tutorial_objects"].append(box)

def advance_tutorial():
    gs["tutorial_stage"] += 1; gs["tutorial_objects"] = []
    stage = gs["tutorial_stage"]
    if stage == 1:
        gs["tutorial_text"] = "Good job! Some boxes move. Track and tap this one."
        box = Box(100, HEIGHT//2-50, 80, 80, COSMIC_MAGENTA, 1); box.speed = 3
        gs["tutorial_objects"].append(box)
    elif stage == 2:
        gs["tutorial_text"] = "Watch out! AVOID clicking gray asteroids. They cost a life."
        asteroid = Asteroid(); asteroid.x, asteroid.y, asteroid.vx, asteroid.vy = WIDTH+20, HEIGHT//2, -3, 0
        gs["tutorial_objects"].append(asteroid)
    elif stage == 3:
        gs["tutorial_text"] = "Collect colorful power-ups for temporary boosts."
        gs["tutorial_objects"].append(PowerUp(WIDTH//2-20, HEIGHT//2-20, "shield"))
    elif stage == 4: gs["tutorial_text"] = "You're ready to play! Good luck."
    else: gs["game_state"] = "mode_select"

def update_game_state():
    state = gs["game_state"]
    
    # NEW: Update background positions for parallax scrolling
    gs["bg_x"] -= gs["bg_speed"]
    if gs["bg_x"] < -WIDTH: gs["bg_x"] = 0
    gs["bg_fg_x"] -= gs["bg_fg_speed"]
    if gs["bg_fg_x"] < -WIDTH: gs["bg_fg_x"] = 0

    if state == "tutorial":
        for obj in gs["tutorial_objects"]:
            if isinstance(obj, Box): obj.update()
            elif isinstance(obj, Asteroid): obj.move()
        if gs["tutorial_stage"] == 2 and not gs["tutorial_objects"]: advance_tutorial()
        return
    if state == "level_clear":
        if time.time() - gs["level_clear_timer"] > 2: gs["level"] += 1; start_new_level()
        return
    if state != "playing": return
    speed_scale = 0.3 if gs["power_up_active"] == "time_warp" else 1.0
    if gs["meteor_shower_warning"] > 0 and time.time() > gs["meteor_shower_warning"]:
        gs["meteor_shower_warning"], gs["meteor_shower_active"] = 0, time.time() + 5
        for _ in range(25): gs["asteroids"].append(Asteroid(is_meteor=True))
    if gs["meteor_shower_active"] > 0 and time.time() > gs["meteor_shower_active"]: gs["meteor_shower_active"] = 0
    if time.time() > gs.get("meteor_event_timer", 0):
        if random.random() < 0.1: gs["meteor_shower_warning"] = time.time() + 3
        gs["meteor_event_timer"] = time.time() + random.uniform(20, 40)
    if gs["game_mode"] == "chaos" and time.time() > gs["chaos_event_timer"]:
        event = random.choice(["flip", "snail", "nothing", "box_storm"])
        if event == "flip": gs["screen_flipped"] = not gs["screen_flipped"]
        elif event == "snail" and not gs["snail"]: gs["snail"] = Snail()
        elif event == "box_storm":
            for _ in range(20):
                size = random.randint(20, 40)
                box = Box(random.randint(0, WIDTH-size), random.randint(0, HEIGHT-size), size, size, random.choice(gs["box_colors"]), BASE_BOX_HEALTH*0.5)
                box.speed *= 1.5; gs["boxes"].append(box)
        gs["chaos_event_timer"] = time.time() + random.uniform(10, 20)
    for nebula in gs["nebulae"]: nebula.update()
    for obj in gs["boxes"] + gs["asteroids"] + [gs["boss"], gs["circle"], gs["snail"]]:
        if obj:
            if hasattr(obj, 'update'):
                orig_speed = getattr(obj, 'speed', 0); obj.speed *= speed_scale; obj.update(); obj.speed = orig_speed
            elif hasattr(obj, 'move'):
                orig_vx, orig_vy = getattr(obj, 'vx', 0), getattr(obj, 'vy', 0); obj.vx *= speed_scale; obj.vy *= speed_scale; obj.move(); obj.vx, obj.vy = orig_vx, orig_vy
    if gs["nyan_cat"]:
        orig_speed = gs["nyan_cat"].speed; gs["nyan_cat"].speed *= speed_scale
        if not gs["nyan_cat"].update(gs["boxes"]): gs["nyan_cat"] = None
        gs["nyan_cat"].speed = orig_speed
    for star in gs["stars"]: star.update()
    if gs["active_black_hole"] and not gs["active_black_hole"].update(gs["boxes"]): gs["active_black_hole"] = None
    for p in gs["particles"][:]:
        if not p.update(): gs["particles"].remove(p)
    spawn_asteroid()
    if gs["power_up_active"]:
        duration = (5 if gs["power_up_active"] in ["freeze", "time_warp"] else 10) + gs["upgrades"]["powerup_time"]
        if time.time() - gs["power_up_timer"] > duration:
            gs["power_up_active"] = None
            if "INVINCIBILITY" not in gs["active_cheats"]: gs["active_cheats"].discard("SHIELD_POWERUP")
    if gs["combo"] > 0 and time.time() - gs["combo_timer"] > 3: gs["combo"] = 0
    if not gs["boxes"] and not gs["boss"] and not gs["circle"]: gs["game_state"], gs["level_clear_timer"] = "level_clear", time.time()

def draw_elements():
    surface = screen.copy() if gs["screen_shake"] > 0 else screen
    
    # NEW: Draw animated parallax background
    bg_sprite = SPRITES.get("background")
    bg_fg_sprite = SPRITES.get("background_foreground")
    if bg_sprite:
        scaled_bg = pygame.transform.scale(bg_sprite, (WIDTH, HEIGHT))
        surface.blit(scaled_bg, (gs['bg_x'], 0))
        surface.blit(scaled_bg, (gs['bg_x'] + WIDTH, 0)) # Draw second copy for seamless scroll
    else:
        surface.fill(BLACK) # Fallback
    if bg_fg_sprite:
        scaled_fg = pygame.transform.scale(bg_fg_sprite, (WIDTH, HEIGHT))
        surface.blit(scaled_fg, (gs['bg_fg_x'], 0))
        surface.blit(scaled_fg, (gs['bg_fg_x'] + WIDTH, 0)) # Draw second copy

    state = gs["game_state"]
    if state == "main_menu": draw_main_menu(surface)
    elif state == "mode_select": draw_mode_select_screen(surface)
    elif state == "difficulty_select": draw_difficulty_select_screen(surface)
    elif state == "stats": draw_stats_screen(surface)
    elif state == "tutorial": draw_tutorial_screen(surface)
    elif state == "shop": draw_shop_screen(surface)
    elif state in ["playing", "paused", "game_over", "victory", "level_clear", "credits"]:
        if state != "credits": draw_game_screen(surface)
        if state == "paused": draw_pause_screen(surface)
        elif state == "game_over": draw_game_over_screen(surface)
        elif state == "victory": draw_victory_screen(surface)
        elif state == "level_clear": draw_level_clear_screen(surface)
        elif state == "credits": draw_credits_screen(surface)
    if gs["screen_flipped"]: surface = pygame.transform.flip(surface, False, True)
    if gs["screen_shake"] > 0:
        gs["screen_shake"] -= 1
        offset = (random.randint(-gs["shake_intensity"], gs["shake_intensity"]), random.randint(-gs["shake_intensity"], gs["shake_intensity"]))
        screen.blit(surface, offset)
    else: screen.blit(surface, (0,0))
    pygame.display.flip()

def draw_game_screen(surface):
    # Background is now drawn in draw_elements, so we draw elements on top
    for nebula in gs["nebulae"]: nebula.draw(surface)
    for star in gs["stars"]: star.draw(surface)
    for obj in gs["boxes"] + gs["asteroids"] + [gs["boss"], gs["circle"], gs["power_up"], gs["snail"], gs["nyan_cat"]]:
        if obj: obj.draw(surface)
    if gs["active_black_hole"]: gs["active_black_hole"].draw(surface)
    for p in gs["particles"]: p.draw(surface)
    draw_cursor(surface)
    if gs["hud_active"]: draw_hud(surface)
    if gs["meteor_shower_warning"] > 0:
        alpha = 255 * (math.sin(time.time() * 5) * 0.5 + 0.5)
        warn_surf = big_font.render("METEOR SHOWER INBOUND!", True, (*RED, alpha))
        surface.blit(warn_surf, warn_surf.get_rect(center=(WIDTH//2, HEIGHT//2)))

def draw_cursor(surface):
    pos = tuple(map(int, gs["cursor_pos"]))
    if "SHIELD_POWERUP" in gs["active_cheats"] or gs["power_up_active"] == "shield":
        radius = int(20 + 6 * math.sin(time.time() * 5))
        aura = pygame.Surface((radius*2, radius*2), pygame.SRCALPHA)
        pygame.draw.circle(aura, (*STARLIGHT_CYAN, 80), (radius, radius), radius)
        surface.blit(aura, (pos[0]-radius, pos[1]-radius))
    pygame.draw.circle(surface, STARLIGHT_CYAN, pos, 10)

def draw_hud(surface):
    hud_surf = pygame.Surface((300, 150), pygame.SRCALPHA); hud_surf.fill((*NEBULA_BLUE, 150))
    pygame.draw.rect(hud_surf, NEBULA_PURPLE, (0,0,300,150), 2); surface.blit(hud_surf, (10,60))
    surface.blit(font.render(f"Lives: {gs['lives']}/{gs['max_lives']}", True, WHITE), (20,70))
    surface.blit(font.render(f"Level: {gs['level']}", True, WHITE), (20,100))
    surface.blit(font.render(f"Score: {int(gs['score'])}", True, WHITE), (20,130))
    surface.blit(font.render(f"Dust: {gs['cosmic_dust']}", True, YELLOW), (20,160))
    for btn in hud_buttons.values(): btn.draw(surface, btn.rect.collidepoint(pygame.mouse.get_pos()))

def draw_main_menu(surface):
    # Stars are now part of the main game screen, not menu-specific
    title = big_font.render("Box Tapper: Evolution", True, WHITE)
    surface.blit(title, title.get_rect(center=(WIDTH//2, HEIGHT//3)))
    mouse_pos = pygame.mouse.get_pos()
    start_button.draw(surface, start_button.is_clicked(mouse_pos))
    stats_button.draw(surface, stats_button.is_clicked(mouse_pos))
    quit_button.draw(surface, quit_button.is_clicked(mouse_pos))

def draw_mode_select_screen(surface):
    title = big_font.render("Select Game Mode", True, WHITE)
    surface.blit(title, title.get_rect(center=(WIDTH//2, 80)))
    for btn in mode_buttons.values(): btn.draw(surface, btn.is_clicked(pygame.mouse.get_pos()))
    back_to_menu_button.draw(surface, back_to_menu_button.is_clicked(pygame.mouse.get_pos()))

def draw_difficulty_select_screen(surface):
    title = big_font.render("Select Difficulty", True, WHITE)
    surface.blit(title, title.get_rect(center=(WIDTH//2, 80)))
    for btn in difficulty_buttons: btn.draw(surface, btn.is_clicked(pygame.mouse.get_pos()))
    back_to_mode_button.draw(surface, back_to_mode_button.is_clicked(pygame.mouse.get_pos()))

def draw_stats_screen(surface):
    # This screen can have a static background if desired
    surface.fill(GALAXY_INDIGO)
    title = big_font.render("Lifetime Stats & Achievements", True, WHITE)
    surface.blit(title, title.get_rect(center=(WIDTH//2, 80)))
    stats = gs["stats"]
    lines = [f"Boxes Tapped: {stats['boxes_tapped']:,}", f"Power-ups Collected: {stats['powerups_collected']:,}", f"Total Score Earned: {int(stats['total_score']):,}", f"Bosses Defeated: {stats['bosses_defeated']:,}", f"Snails Harmed: {stats['snails_harmed']:,}"]
    for i, line in enumerate(lines):
        text = stats_font.render(line, True, WHITE if "Snails" not in line else RED)
        surface.blit(text, text.get_rect(center=(WIDTH//2, 200 + i*60)))
    ach_title = big_font.render("Achievements", True, WHITE); surface.blit(ach_title, ach_title.get_rect(center=(WIDTH//2, 500)))
    for i, (name, ach) in enumerate(gs["achievements"].items()):
        text = font.render(f"{ach['description']} ({ach['reward']} Dust)", True, GOLD if ach["unlocked"] else GRAY)
        surface.blit(text, text.get_rect(center=(WIDTH//2, 560 + i*40)))
    back_to_menu_button.draw(surface, back_to_menu_button.is_clicked(pygame.mouse.get_pos()))

def draw_tutorial_screen(surface):
    # Uses the main animated background
    for obj in gs["tutorial_objects"]: obj.draw(surface)
    text_surf = tutorial_font.render(gs["tutorial_text"], True, WHITE)
    text_rect = text_surf.get_rect(center=(WIDTH//2, 150))
    bg_rect = text_rect.inflate(40,20)
    bg_surf = pygame.Surface(bg_rect.size, pygame.SRCALPHA); bg_surf.fill((*GALAXY_INDIGO, 200))
    surface.blit(bg_surf, bg_rect); surface.blit(text_surf, text_rect)

def draw_screen_overlay(surface, title):
    overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA); overlay.fill((0,0,0,200)); surface.blit(overlay, (0,0))
    if title:
        text = big_font.render(title, True, WHITE)
        surface.blit(text, text.get_rect(center=(WIDTH//2, HEIGHT//2)))

def draw_pause_screen(surface):
    draw_screen_overlay(surface, "Paused")
    mouse_pos = pygame.mouse.get_pos()
    resume_button.draw(surface, resume_button.is_clicked(mouse_pos))
    shop_button.draw(surface, shop_button.is_clicked(mouse_pos))
    main_menu_button.draw(surface, main_menu_button.is_clicked(mouse_pos))

def draw_game_over_screen(surface):
    draw_screen_overlay(surface, "Game Over!")
    score = font.render(f"Final Score: {int(gs['score'])}", True, WHITE)
    surface.blit(score, score.get_rect(center=(WIDTH//2, HEIGHT//2+60)))
    reset_button.draw(surface, reset_button.is_clicked(pygame.mouse.get_pos()))

def draw_victory_screen(surface):
    draw_screen_overlay(surface, "")
    lines = [f"Congratulations! You've beaten Level {MAX_LEVEL_CLASSIC}!", f"Final Score: {int(gs['score'])}", "Thanks for playing!"]
    for i, line in enumerate(lines):
        text = font.render(line, True, WHITE)
        surface.blit(text, text.get_rect(center=(WIDTH//2, HEIGHT//2 - 100 + i*50)))
    continue_button.draw(surface, continue_button.is_clicked(pygame.mouse.get_pos()))

def draw_credits_screen(surface):
    draw_screen_overlay(surface, "")
    lines = ["ENDGAME CREDITS", "DESIGNER: TONMOY KS", "TASK MANAGER: TONMOY KS", "CONCEPT ARTIST: TONMOY KS", "PUBLISHER: TONMOY KS", "", "THE END"]
    for i, line in enumerate(lines):
        text = font.render(line, True, WHITE)
        surface.blit(text, text.get_rect(center=(WIDTH//2, HEIGHT//2 - 150 + i*40)))
    exit_button.draw(surface, exit_button.is_clicked(pygame.mouse.get_pos()))

def draw_level_clear_screen(surface):
    text = big_font.render("Level Clear!", True, GOLD)
    surface.blit(text, text.get_rect(center=(WIDTH//2, HEIGHT//2)))

def draw_shop_screen(surface):
    surface.fill(GALAXY_INDIGO)
    title = big_font.render("Upgrade Shop", True, WHITE); surface.blit(title, title.get_rect(center=(WIDTH//2, 80)))
    dust = font.render(f"Cosmic Dust: {gs['cosmic_dust']}", True, YELLOW); surface.blit(dust, dust.get_rect(center=(WIDTH//2, 150)))
    for name, btn in shop_buttons.items():
        level, cost = gs["upgrades"][name], UPGRADE_COSTS[name] * (2 ** gs["upgrades"][name])
        btn.text = f"{UPGRADE_NAMES[name]} ({level}) - Cost: {cost}"
        btn.draw(surface, btn.is_clicked(pygame.mouse.get_pos()))
    back_button.draw(surface, back_button.is_clicked(pygame.mouse.get_pos()))

def handle_input():
    global running, WIDTH, HEIGHT
    for event in pygame.event.get():
        if event.type == pygame.QUIT: running = False
        elif event.type == pygame.VIDEORESIZE:
            WIDTH, HEIGHT = event.w, event.h
            pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: handle_mouse_click(event.pos)
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
            if gs["game_state"] == "playing": gs["game_state"] = "paused"
            elif gs["game_state"] == "paused": gs["game_state"] = "playing"

def handle_mouse_click(pos):
    global running
    state = gs["game_state"]
    if state == "main_menu":
        if start_button.is_clicked(pos): gs["game_state"] = "mode_select"
        elif stats_button.is_clicked(pos): gs["game_state"] = "stats"
        elif quit_button.is_clicked(pos): running = False
    elif state == "mode_select":
        if back_to_menu_button.is_clicked(pos): gs["game_state"] = "main_menu"
        for mode, btn in mode_buttons.items():
            if btn.is_clicked(pos):
                gs["game_mode"] = mode
                if mode in ["classic", "endless"]: gs["game_state"] = "difficulty_select"
                else: reset_game_state("casual", mode)
    elif state == "difficulty_select":
        if back_to_mode_button.is_clicked(pos): gs["game_state"] = "mode_select"
        for btn in difficulty_buttons:
            if btn.is_clicked(pos):
                diff = btn.text.lower()
                if diff == "tutorial": start_tutorial()
                else: reset_game_state(diff, gs["game_mode"])
    elif state == "stats":
        if back_to_menu_button.is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "tutorial":
        for obj in gs["tutorial_objects"][:]:
            if obj.rect.collidepoint(pos):
                if isinstance(obj, Asteroid): return
                gs["tutorial_objects"].remove(obj); advance_tutorial(); break
    elif state == "paused":
        if resume_button.is_clicked(pos): gs["game_state"] = "playing"
        elif shop_button.is_clicked(pos): gs["game_state"] = "shop"
        elif main_menu_button.is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "playing":
        gs["cursor_pos"] = list(pos)
        if gs["hud_active"]:
            if hud_buttons["hud"].is_clicked(pos): gs["hud_active"] = False; return
            if hud_buttons["reset"].is_clicked(pos): gs["game_state"] = "main_menu"; return
            if hud_buttons["debug"].is_clicked(pos): activate_cheat("DEBUG_MODE"); return
        handle_gameplay_click(pos)
    elif state == "game_over" and reset_button.is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "victory" and continue_button.is_clicked(pos): gs["game_state"] = "credits"
    elif state == "credits" and exit_button.is_clicked(pos): running = False
    elif state == "shop":
        if back_button.is_clicked(pos): gs["game_state"] = "paused"
        for name, btn in shop_buttons.items():
            if btn.is_clicked(pos): purchase_upgrade(name)

def handle_gameplay_click(pos):
    if gs["power_up_active"] == "black_hole": gs["active_black_hole"], gs["power_up_active"] = BlackHole(*pos), None; return
    hit = False
    if gs["snail"] and gs["snail"].rect.collidepoint(pos):
        gs["score"] -= 5000; gs["snail"] = None; gs["stats"]["snails_harmed"] += 1; hit = True
    for ast in gs["asteroids"][:]:
        if ast.rect.collidepoint(pos):
            if not ("INVINCIBILITY" in gs["active_cheats"] or "SHIELD_POWERUP" in gs["active_cheats"] or gs["power_up_active"] == "shield"): gs["lives"] -= 1
            gs["asteroids"].remove(ast); hit = True; break
    if hit: return
    if gs["power_up_active"] == "multi_tap":
        hit = True
        for box in gs["boxes"][:]:
            if math.hypot(box.rect.centerx - pos[0], box.rect.centery - pos[1]) < 75: damage_box(box)
    else:
        for box in gs["boxes"][:]:
            if box.rect.collidepoint(pos): hit = True; damage_box(box); break
    if not hit:
        if gs["boss"] and gs["boss"].rect.collidepoint(pos): hit = True; handle_boss_hit()
        elif gs["circle"] and gs["circle"].rect.collidepoint(pos): hit = True; handle_circle_hit()
        elif gs["power_up"] and gs["power_up"].rect.collidepoint(pos): hit = True; handle_powerup_hit()
    if not hit:
        gs["player_sequence"].append("hit_empty")
        if not ("INVINCIBILITY" in gs["active_cheats"] or "SHIELD_POWERUP" in gs["active_cheats"] or gs["power_up_active"] == "shield"): gs["lives"] -= 1
        gs["combo"] = 0
    if gs["lives"] <= 0: gs["game_state"] = "game_over"; save_high_scores(); save_stats()
    if len(gs["player_sequence"]) > 10: gs["player_sequence"].pop(0)

def damage_box(box, is_black_hole=False):
    if box.is_dying: return
    if not is_black_hole:
        gs["player_sequence"].append("hit_box")
        if box.special_type == "multi":
            if box.tap_timer == 0 or time.time() - box.tap_timer > 1: box.tap_timer, box.tap_count = time.time(), 1
            else: box.tap_count += 1
            if box.tap_count >= box.taps_required: box.health = 0; gs["score"] += 20 * gs["score_multiplier"]
        else:
            damage = gs["upgrades"]["damage"] + 1
            dealt = gs["equipped_tool"].damage * damage if "INSTANT_KILL" not in gs["active_cheats"] else box.max_health
            box.health -= dealt
    else: box.health = 0
    if box.health <= 0:
        if box.special_type == "dramatic": box.is_dying, box.death_timer, box.death_quote, box.speed = True, time.time() + 2, random.choice(DRAMATIC_QUOTES), 0; return
        gs["stats"]["boxes_tapped"] += 1
        create_explosion(box.rect.centerx, box.rect.centery, box.color)
        if box.special_type == "splitter":
            for _ in range(2):
                size = max(20, int(box.rect.width * 0.7))
                child = Box(box.rect.centerx, box.rect.centery, size, size, GREEN, max(1, box.max_health * 0.5), True)
                gs["boxes"].append(child)
        if box.special_type == "explosive":
            for b in gs["boxes"][:]:
                if b != box: b.health = 0
            if "INVINCIBILITY" not in gs["active_cheats"]: gs["lives"] -= 1
            trigger_screen_shake()
        if box.special_type == "golden": gs["score"] += 500
        if box.special_type == "rainbow": gs["score"] += 1000
        if box in gs["boxes"]: gs["boxes"].remove(box)
        diff_mods = DIFFICULTY_SETTINGS[gs["difficulty"]]
        dust_bonus = 1 + (gs["upgrades"]["dust_bonus"] * 0.2)
        gs["cosmic_dust"] += int(1 * dust_bonus * diff_mods["dust_mod"])
        score_gain = (10 * gs["score_multiplier"] * (1 + gs["combo"]*0.5)) * diff_mods["score_mod"]
        gs["score"] += score_gain; gs["stats"]["total_score"] += score_gain
        gs["combo"] += 1; gs["combo_timer"] = time.time()

def handle_boss_hit():
    if random.random() > gs["boss"].dodge_chance:
        gs["boss"].health -= (gs["equipped_tool"].damage + gs["upgrades"]["damage"])
        if gs["boss"].health <= 0:
            gs["score"] += 50 * (1 + gs["combo"] * 0.5); gs["boss"] = None; gs["stats"]["bosses_defeated"] += 1
            gs["game_state"], gs["level_clear_timer"] = "level_clear", time.time()
        else: gs["boss"].update_phase()

def handle_circle_hit(): gs["lives"] = min(gs["lives"] + 1, gs["max_lives"] + 1); gs["max_lives"] += 1; gs["circle"] = None

def handle_powerup_hit():
    gs["power_up_active"], gs["power_up_timer"] = gs["power_up"].type, time.time()
    gs["stats"]["powerups_collected"] += 1
    if gs["power_up_active"] == "nyan": gs["nyan_cat"] = NyanCat()
    elif gs["power_up_active"] == "shield": gs["active_cheats"].add("SHIELD_POWERUP")
    gs["power_up"] = None

UPGRADE_COSTS = {"damage": 20, "lives": 50, "dust_bonus": 100, "powerup_time": 75}
UPGRADE_NAMES = {"damage": "Tap Power", "lives": "Max Lives", "dust_bonus": "Dust Bonus", "powerup_time": "Power-up Time"}
def purchase_upgrade(name):
    level = gs["upgrades"][name]
    cost = UPGRADE_COSTS[name] * (2 ** level)
    if gs["cosmic_dust"] >= cost:
        gs["cosmic_dust"] -= cost; gs["upgrades"][name] += 1
        if name == "lives": gs["max_lives"] += 1; gs["lives"] += 1

# --- UI ELEMENT SETUP ---
hud_buttons = {"hud": Button(10, 10, 100, 40, "HUD", STARLIGHT_CYAN, WHITE), "reset": Button(120, 10, 100, 40, "Menu", GRAY, WHITE), "debug": Button(230, 10, 100, 40, "Debug", COSMIC_MAGENTA, WHITE)}
reset_button = Button(WIDTH//2-100, HEIGHT//2+120, 200, 60,"To Menu",GRAY,WHITE)
continue_button = Button(WIDTH//2-100, HEIGHT//2+150, 200, 60,"Continue",GRAY,WHITE)
exit_button = Button(WIDTH//2-100, HEIGHT//2+250, 200, 60,"Exit",GRAY,WHITE)
start_button = Button(WIDTH//2-100, HEIGHT//2-40, 200, 60, "Start Game", AURORA_GREEN, WHITE)
stats_button = Button(WIDTH//2-100, HEIGHT//2+40, 200, 60, "Stats", STARLIGHT_CYAN, WHITE)
quit_button = Button(WIDTH//2-100, HEIGHT//2+120, 200, 60, "Quit", GRAY, WHITE)
resume_button = Button(WIDTH//2-150, HEIGHT//2-100, 300, 60, "Resume", AURORA_GREEN, WHITE)
shop_button = Button(WIDTH//2-150, HEIGHT//2, 300, 60, "Shop", STARLIGHT_CYAN, WHITE)
main_menu_button = Button(WIDTH//2-150, HEIGHT//2+100, 300, 60, "Main Menu", GRAY, WHITE)
back_button = Button(WIDTH//2-150, HEIGHT-100, 300, 60, "Back", GRAY, WHITE)
shop_buttons = {"damage": Button(WIDTH//2-250,200,500,60,"",AURORA_GREEN,WHITE), "lives": Button(WIDTH//2-250,280,500,60,"",STARLIGHT_CYAN,WHITE), "dust_bonus": Button(WIDTH//2-250,360,500,60,"",GOLD,BLACK), "powerup_time": Button(WIDTH//2-250,440,500,60,"",COSMIC_MAGENTA,WHITE)}
mode_buttons = {"classic": Button(WIDTH//2-150, 150, 300, 60, "Classic", YELLOW, WHITE), "endless": Button(WIDTH//2-150, 230, 300, 60, "Endless", STARLIGHT_CYAN, WHITE), "boss_rush": Button(WIDTH//2-150, 310, 300, 60, "Boss Rush", RED, WHITE), "chaos": Button(WIDTH//2-150, 390, 300, 60, "Chaos", COSMIC_MAGENTA, WHITE), "stealth": Button(WIDTH//2-150, 470, 300, 60, "Stealth", DARK_GRAY, WHITE)}
difficulty_buttons = [Button(WIDTH//2-150, 180+i*70, 300, 60, n, c, WHITE) for i,(n,c) in enumerate(zip(["Tutorial","Easy","Beginner","Casual","Hardcore","Insane","Demon"], [STARLIGHT_CYAN,AURORA_GREEN,AURORA_GREEN,YELLOW,RED,COSMIC_MAGENTA,NEBULA_PURPLE]))]
back_to_menu_button = Button(WIDTH//2-150, HEIGHT-100, 300, 60, "Back to Menu", GRAY, WHITE)
back_to_mode_button = Button(WIDTH//2-150, 180+7*70, 300, 60, "Back", GRAY, WHITE)

def reset_game_state(difficulty, game_mode):
    global gs
    old_upgrades, old_scores, old_stats = gs["upgrades"], gs["high_scores"], gs["stats"]
    gs = setup_game_variables(difficulty, game_mode)
    gs["upgrades"], gs["high_scores"], gs["stats"] = old_upgrades, old_scores, old_stats
    gs["max_lives"] += gs["upgrades"]["lives"]
    gs["lives"] = gs["max_lives"]
    start_new_level()

# --- MAIN GAME LOOP ---
if __name__ == "__main__":
    load_all_assets()
    gs = setup_game_variables()
    spawn_stars()
    running = True

    if music_loaded:
        pygame.mixer.music.play(loops=-1)

    while running:
        handle_input()
        update_game_state()
        draw_elements()
        clock.tick(FPS)
    
    save_stats()
    pygame.quit()