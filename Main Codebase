import pygame
import random
import math
import os
import time
import json


# SETTINGS & CONSTANTS

# --- Display ---
WIDTH = 1280
HEIGHT = 720
FPS = 60

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (150, 150, 150)
DARK_GRAY = (50, 50, 50)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GOLD = (255, 215, 0)
NEBULA_BLUE = (50, 50, 200)
NEBULA_PURPLE = (150, 50, 200)
GALAXY_INDIGO = (75, 0, 130)
STARLIGHT_CYAN = (100, 200, 255)
COSMIC_MAGENTA = (200, 50, 200)
AURORA_GREEN = (50, 200, 150)
SLIME_GREEN = (124, 252, 0)
DEEP_PURPLE = (66, 30, 93)

# --- Terminal Color Codes ---
XTERM_BLUE = "\033[94m"
XTERM_YELLOW = "\033[93m"
XTERM_RESET = "\033[0m"

# --- Game Mechanics ---
BASE_BOX_HEALTH = 1
BOSS_HEALTH_MULTIPLIER = 2
MAX_HIGH_SCORES = 5
MAX_LEVEL = 100
ASTEROID_START_LEVEL = 30


# INITIALIZATION
pygame.init()
os.environ['SDL_VIDEO_CENTERED'] = '1'
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
pygame.display.set_caption("Box Tapper: Evolution (Stub-Free)")
clock = pygame.time.Clock()
font = pygame.font.Font(None, 36)
big_font = pygame.font.Font(None, 72)
button_font = pygame.font.Font(None, 48)
tutorial_font = pygame.font.Font(None, 42)
small_font = pygame.font.Font(None, 24)


# --- Difficulty Settings ---
DIFFICULTY_SETTINGS = {
    "easy":       {"lives": 20, "health_mod": 0.5, "speed_mod": 0.7, "spawn_mod": 0.8, "asteroid_mod": 0.5, "score_mod": 0.75, "dust_mod": 1.5},
    "beginner":   {"lives": 15, "health_mod": 0.8, "speed_mod": 0.9, "spawn_mod": 0.9, "asteroid_mod": 0.8, "score_mod": 0.9,  "dust_mod": 1.2},
    "casual":     {"lives": 10, "health_mod": 1.0, "speed_mod": 1.0, "spawn_mod": 1.0, "asteroid_mod": 1.0, "score_mod": 1.0,  "dust_mod": 1.0},
    "hardcore":   {"lives": 5,  "health_mod": 1.5, "speed_mod": 1.2, "spawn_mod": 1.2, "asteroid_mod": 1.3, "score_mod": 1.25, "dust_mod": 1.25},
    "insane":     {"lives": 3,  "health_mod": 2.0, "speed_mod": 1.5, "spawn_mod": 1.5, "asteroid_mod": 1.6, "score_mod": 1.5,  "dust_mod": 1.5},
    "demon":      {"lives": 1,  "health_mod": 3.0, "speed_mod": 2.0, "spawn_mod": 2.0, "asteroid_mod": 2.0, "score_mod": 2.0,  "dust_mod": 2.0},
}


# CLASSES

class Tool:
    """Represents a tapper tool with different abilities."""
    def __init__(self, id, level, damage, score_multiplier, is_dev):
        self.id, self.level, self.damage, self.score_multiplier, self.is_dev = id, level, damage, score_multiplier, is_dev

class Star:
    """A twinkling star in the background."""
    def __init__(self, w, h):
        self.x, self.y = random.randint(0, w), random.randint(0, h)
        self.radius, self.color = random.randint(1, 3), WHITE
        self.alpha, self.fade_speed = random.randint(50, 255), random.uniform(0.5, 2.0)

    def update(self):
        self.alpha += self.fade_speed
        if self.alpha >= 255 or self.alpha <= 50: self.fade_speed *= -1
        self.alpha = max(50, min(255, self.alpha))

    def draw(self, surface):
        star_surf = pygame.Surface((self.radius * 2, self.radius * 2), pygame.SRCALPHA)
        pygame.draw.circle(star_surf, (*self.color, int(self.alpha)), (self.radius, self.radius), self.radius)
        surface.blit(star_surf, (self.x - self.radius, self.y - self.radius))

class Particle:
    """A particle for explosion effects."""
    def __init__(self, x, y, color):
        self.x, self.y, self.color = x, y, color
        self.vx, self.vy = random.uniform(-3, 3), random.uniform(-3, 3)
        self.lifespan, self.radius = random.randint(20, 40), random.randint(2, 5)
        self.gravity = 0
        if gs.get("chaotic_particles"):
            self.vx, self.vy = random.uniform(-5, 5), random.uniform(-5, 5)
            self.lifespan, self.radius = random.randint(30, 60), random.randint(3, 7)
            self.gravity = 0.1

    def update(self):
        self.x += self.vx; self.y += self.vy; self.vy += self.gravity
        self.lifespan -= 1; self.radius -= 0.1
        return self.lifespan > 0 and self.radius > 0

    def draw(self, surface):
        if self.radius > 0: pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), int(self.radius))

class Asteroid:
    """A moving hazard that the player must avoid clicking."""
    def __init__(self, w, h):
        self.w, self.h = w, h
        start_side = random.choice(['left', 'right', 'top', 'bottom'])
        if start_side == 'left': self.x, self.y, self.vx, self.vy = -20, random.randint(0, h), random.uniform(2, 4), random.uniform(-1, 1)
        elif start_side == 'right': self.x, self.y, self.vx, self.vy = w + 20, random.randint(0, h), random.uniform(-4, -2), random.uniform(-1, 1)
        elif start_side == 'top': self.x, self.y, self.vx, self.vy = random.randint(0, w), -20, random.uniform(-1, 1), random.uniform(2, 4)
        else: self.x, self.y, self.vx, self.vy = random.randint(0, w), h + 20, random.uniform(-1, 1), random.uniform(-4, -2)
        self.radius = random.randint(10, 25)
        self.rect = pygame.Rect(self.x-self.radius, self.y-self.radius, self.radius*2, self.radius*2)

    def move(self):
        self.x += self.vx; self.y += self.vy
        self.rect.center = (self.x, self.y)

    def is_offscreen(self): return self.rect.right < 0 or self.rect.left > self.w or self.rect.bottom < 0 or self.rect.top > self.h
    def draw(self, surface): pygame.draw.circle(surface, DARK_GRAY, self.rect.center, self.radius); pygame.draw.circle(surface, GRAY, self.rect.center, self.radius, 2)

class Box:
    """The main target object for the player to tap."""
    def __init__(self, x, y, width, height, color, health):
        self.rect = pygame.Rect(int(x), int(y), width, height)
        self.color, self.health, self.max_health = color, health, health
        self.speed = 5 * (DIFFICULTY_SETTINGS.get(gs.get("difficulty"), {}).get("speed_mod", 1.0))
        self.direction = random.choice([-1, 1])
        self.special_type, self.alpha, self.fade_timer = None, 255, 0
        self.tap_count, self.tap_timer, self.taps_required = 0, 0, 0
        self.is_shrinking, self.shrink_rate, self.min_size = False, 0.25, 20
        self.original_width, self.original_height = width, height
        self.teleport_timer = 0
        self.dramatic_death_timer = 0
        self.dramatic_quote = ""
        self.assign_special_type()

    def assign_special_type(self):
        roll = random.random()
        allowed_types = gs.get("allowed_special_boxes", [])
        
        if roll < 0.02: self.special_type, self.color, self.health, self.speed = "golden", GOLD, 3, 8
        elif roll < 0.3 and allowed_types:
            self.special_type = random.choice(allowed_types)
            if self.special_type == "splitter": self.color = SLIME_GREEN
            elif self.special_type == "dramatic": self.color = DEEP_PURPLE
            elif self.special_type == "teleporter": self.color = COSMIC_MAGENTA
            elif self.special_type == "shrinking": self.is_shrinking = True

        elif random.random() < 0.1:
            self.special_type, self.taps_required = "multi", min(1 + gs["level"] // 10, 5)

    def update(self):
        w, h = pygame.display.get_surface().get_size()
        self.rect.x += self.speed * self.direction
        if gs.get("gravity_reversed"): self.rect.y -= 2
        
        if self.rect.left <= 0 or self.rect.right >= w: self.direction *= -1
        
        if self.special_type == "teleporter" and time.time() - self.teleport_timer > 3:
            self.rect.x, self.rect.y = random.randint(0, w - self.rect.width), random.randint(0, h - self.rect.height)
            self.teleport_timer = time.time()
            
        if self.dramatic_death_timer > 0:
            self.alpha = max(0, self.alpha - 4)
            if self.alpha == 0: self.health = 0

    def draw(self, surface):
        visibility_alpha = self.alpha
        if gs.get("stealth_mode_active"):
            if time.time() - self.fade_timer > 0.1: self.alpha = 50
            else: self.alpha = 255
            visibility_alpha = self.alpha

        box_surf = pygame.Surface(self.rect.size, pygame.SRCALPHA); box_surf.fill((*self.color, visibility_alpha))
        surface.blit(box_surf, self.rect.topleft)
        
        if self.max_health > 1:
            health_ratio = self.health / self.max_health
            pygame.draw.rect(surface, GREEN, (self.rect.x, self.rect.y - 10, self.rect.width * health_ratio, 5))
            
        if self.dramatic_death_timer > 0:
            text_surf = small_font.render(self.dramatic_quote, True, WHITE)
            surface.blit(text_surf, text_surf.get_rect(center=self.rect.center))

    def start_dramatic_death(self):
        self.dramatic_death_timer = time.time()
        self.speed = 0
        quotes = ["Et tu, Brute?", "I'm melting!", "My only regret...", "Tell my wife I love her.", "This is not in my contract!"]
        self.dramatic_quote = random.choice(quotes)
        self.color = GRAY

class Boss(Box):
    def __init__(self, x, y, width, height, color, health):
        super().__init__(x, y, width, height, color, health)
        self.dodge_chance = 0.3
        self.base_speed = 5 * (DIFFICULTY_SETTINGS.get(gs.get("difficulty"), {}).get("speed_mod", 1.0))
        self.speed = int(self.base_speed * (1 + 0.005 * (gs["level"] // 5)))
        self.phase, self.minions = 1, []

class PowerUp:
    def __init__(self, x, y, type):
        self.rect = pygame.Rect(x, y, 40, 40)
        self.type = type
        self.colors = {"cosmic": NEBULA_PURPLE, "nyan": GRAY, "shield": STARLIGHT_CYAN}
        self.color = self.colors.get(type, YELLOW)

    def draw(self, surface):
        pygame.draw.rect(surface, self.color, self.rect)
        char = {"cosmic": "C", "nyan": "N", "shield": "S"}.get(self.type, self.type[0].upper())
        text = font.render(char, True, WHITE)
        surface.blit(text, text.get_rect(center=self.rect.center))

class NyanCat:
    def __init__(self, w, h):
        self.w, self.h = w, h
        self.y = random.randint(50, h - 50)
        self.x = -100
        self.speed = 15
        self.rect = pygame.Rect(self.x, self.y, 100, 50)
        self.trail = []

    def update(self, boxes):
        self.x += self.speed
        self.rect.x = self.x
        self.trail.append((self.rect.left, self.rect.centery))
        if len(self.trail) > 50: self.trail.pop(0)
        for box in boxes:
            if self.rect.colliderect(box.rect):
                box.special_type, box.color = "rainbow", (random.randint(100,255), random.randint(100,255), random.randint(100,255))
        return self.x < self.w + 100

    def draw(self, surface):
        for i, pos in enumerate(self.trail):
            color = pygame.Color(0,0,0); color.hsva = ((i * 10) % 360, 100, 100, 100)
            pygame.draw.rect(surface, color, (pos[0], pos[1]-15, 20, 30))
        pygame.draw.rect(surface, GRAY, self.rect)
        pygame.draw.rect(surface, COSMIC_MAGENTA, self.rect.inflate(-10, -10))

class Snail:
    def __init__(self, w, h):
        self.w, self.h = w, h
        self.y = random.choice([30, h - 30])
        self.x = -30 if random.random() > 0.5 else w + 30
        self.speed = 0.5 * (-1 if self.x > w else 1)
        self.rect = pygame.Rect(self.x, self.y, 30, 15)

    def update(self):
        self.x += self.speed
        self.rect.x = self.x
        return abs(self.x - self.w/2) < self.w/2 + 50

    def draw(self, surface):
        pygame.draw.rect(surface, GREEN, self.rect)
        text = small_font.render(":)", True, BLACK)
        surface.blit(text, self.rect.center)

class Button:
    def __init__(self, x, y, width, height, text, color, text_color, hover_color=None, flavor=""):
        self.rect = pygame.Rect(x, y, width, height)
        self.text, self.color, self.text_color, self.hover_color, self.flavor = text, color, text_color, hover_color or color, flavor

    def draw(self, surface, is_hovered=False):
        current_color = self.hover_color if is_hovered else self.color
        pygame.draw.rect(surface, DARK_GRAY, self.rect.inflate(8, 8), border_radius=12)
        pygame.draw.rect(surface, current_color, self.rect, border_radius=8)
        text_surface = button_font.render(self.text, True, self.text_color)
        surface.blit(text_surface, text_surface.get_rect(center=self.rect.center))
        if is_hovered and self.flavor:
            flavor_surf = small_font.render(self.flavor, True, WHITE)
            flavor_rect = flavor_surf.get_rect(center=(self.rect.centerx, self.rect.bottom + 20))
            surface.blit(flavor_surf, flavor_rect)

    def is_clicked(self, pos): return self.rect.collidepoint(pos)

# --------------------------------------------------------------------------
# GAME MODE SPECIFIC LOGIC
# --------------------------------------------------------------------------

def start_level_chaos():
    w, h = pygame.display.get_surface().get_size()
    if random.random() < 0.1 and not gs.get("active_snail"): gs["active_snail"] = Snail(w,h)
    if random.random() < 0.05: gs["meteor_shower_timer"] = time.time() + 2

def update_mode_chaos():
    w, h = pygame.display.get_surface().get_size()
    if gs["active_nyan"] and not gs["active_nyan"].update(gs["boxes"]): gs["active_nyan"] = None
    if gs["active_snail"] and not gs["active_snail"].update(): gs["active_snail"] = None
    
    if gs["meteor_shower_timer"] and time.time() > gs["meteor_shower_timer"]:
        if time.time() - gs["meteor_shower_timer"] < 5:
            if random.random() < 0.5: gs["asteroids"].append(Asteroid(w,h))
        else: gs["meteor_shower_timer"] = 0
    
    if time.time() - gs["chaos_event_timer"] > 15:
        event = random.choice(["flip", "gravity", "asteroids"])
        gs["chaos_event_timer"] = time.time()
        if event == "flip": gs["screen_flipped"] = not gs["screen_flipped"]
        elif event == "gravity": gs["gravity_reversed"] = not gs["gravity_reversed"]
        elif event == "asteroids": gs["meteor_shower_timer"] = time.time() + 1
    
    if time.time() - gs["chaos_event_timer"] > 7:
        gs["screen_flipped"], gs["gravity_reversed"] = False, False

def draw_mode_chaos(surface):
    w, h = pygame.display.get_surface().get_size()
    if gs["active_nyan"]: gs["active_nyan"].draw(surface)
    if gs["active_snail"]: gs["active_snail"].draw(surface)
    if gs["meteor_shower_timer"] and time.time() < gs["meteor_shower_timer"]:
        warn_text = big_font.render("!!! METEOR SHOWER INCOMING !!!", True, RED)
        surface.blit(warn_text, warn_text.get_rect(center=(w//2, h//2)))

# --- GAME MODE CONFIGURATION DICTIONARY ---
GAME_MODES = {
    "classic": {
        "allowed_boxes": ["explosive", "regen", "shrinking", "splitter"],
        "allowed_powerups": ["shield", "cosmic"],
        "box_multiplier": 1.0, "chaotic_particles": False, "stealth": False
    },
    "chaos_mode": {
        "update_logic": update_mode_chaos, "draw_logic": draw_mode_chaos, "start_level_logic": start_level_chaos,
        "allowed_boxes": ["dramatic", "teleporter"],
        "allowed_powerups": ["shield", "cosmic", "nyan"],
        "box_multiplier": 3.0, "chaotic_particles": True, "stealth": False
    },
    "stealth_mode": {
        "allowed_boxes": [], "allowed_powerups": ["shield"],
        "box_multiplier": 0.5, "chaotic_particles": False, "stealth": True
    },
    "boss_rush": {
        "allowed_boxes": [], "allowed_powerups": ["shield"],
        "box_multiplier": 0.0, "chaotic_particles": True, "stealth": False
    }
}


# GAME STATE & VARIABLES

def setup_game_variables():
    """Only sets up the main menu state. Game mode is configured later."""
    return {
        "game_state": "main_menu",
        "stars": [Star(*pygame.display.get_surface().get_size()) for _ in range(100)],
        "high_scores": load_high_scores(),
        "stats": load_stats(),
        "upgrades": {"damage": 0, "lives": 0, "dust_bonus": 0, "powerup_time": 0}
    }


# HELPER FUNCTIONS

def load_from_file(filename, default_data):
    try:
        with open(filename, "r") as f: return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError): return default_data

def save_to_file(filename, data):
    with open(filename, "w") as f: json.dump(data, f, indent=4)

def load_high_scores(): return load_from_file("highscores.json", [0]*MAX_HIGH_SCORES)
def save_high_scores():
    gs["high_scores"].append(int(gs["score"]))
    gs["high_scores"] = sorted(list(set(gs["high_scores"])), reverse=True)[:MAX_HIGH_SCORES]
    save_to_file("highscores.json", gs["high_scores"])

def load_stats():
    default_stats = {"total_taps": 0, "total_boxes": 0, "powerups_collected": 0, "snails_harmed": 0}
    return load_from_file("gamestats.json", default_stats)
def save_stats(): save_to_file("gamestats.json", gs["stats"])

def start_new_level():
    w, h = pygame.display.get_surface().get_size()
    gs["game_state"] = "playing"
    if gs["game_mode_name"] == "classic" and gs["level"] > MAX_LEVEL: gs["game_state"] = "victory"; return
    gs["boxes"], gs["boss"], gs["asteroids"] = [], None, []
    
    if gs["game_mode_name"] == "boss_rush": spawn_boss()
    elif gs["level"] % 5 == 0: spawn_boss()
    else: spawn_boxes()
    
    spawn_power_up()
    if not gs["stars"]: gs["stars"] = [Star(w,h) for _ in range(100)]
    
    start_logic = gs.get("start_level_mode_logic")
    if start_logic: start_logic()

def create_explosion(x, y, color):
    for _ in range(25 if gs["chaotic_particles"] else 10): gs["particles"].append(Particle(x, y, color))

def spawn_boxes():
    w, h = pygame.display.get_surface().get_size()
    base_num = int((5 + gs["level"] // 5) * DIFFICULTY_SETTINGS[gs["difficulty"]]["spawn_mod"])
    num_boxes = int(base_num * gs["box_spawn_multiplier"])
    
    for _ in range(num_boxes):
        size = random.randint(30, 80)
        x, y = random.randint(0, w - size), random.randint(0, h - size)
        color = random.choice(gs.get("box_colors", [RED]))
        health = BASE_BOX_HEALTH * DIFFICULTY_SETTINGS[gs["difficulty"]]["health_mod"]
        gs["boxes"].append(Box(x, y, size, size, color, health))

def spawn_boss():
    w, h = pygame.display.get_surface().get_size()
    size = int(150 * (1 + gs["level"] * 0.05))
    pos = (w//2 - size//2, h//2 - size//2)
    health = (BASE_BOX_HEALTH * (BOSS_HEALTH_MULTIPLIER ** (gs["level"] // 5))) * DIFFICULTY_SETTINGS[gs["difficulty"]]["health_mod"]
    if gs["game_mode_name"] == "boss_rush": health *= (1 + gs["level"] * 0.2)
    gs["boss"] = Boss(*pos, size, size, NEBULA_PURPLE, health)

def spawn_power_up():
    w, h = pygame.display.get_surface().get_size()
    allowed = gs.get("allowed_powerups", [])
    if random.random() < 0.2 and allowed:
        powerup_type = random.choice(allowed)
        gs["power_up"] = PowerUp(random.randint(0, w-40), random.randint(0, h-40), powerup_type)


# GAME LOGIC (UPDATE)
def update_game_state():
    if gs["game_state"] != "playing": return

    for box in gs["boxes"]: box.update()
    if gs["boss"]: gs["boss"].update()
    for star in gs["stars"]: star.update()
    for p in gs["particles"][:]:
        if not p.update(): gs["particles"].remove(p)
    for asteroid in gs["asteroids"][:]:
        asteroid.move()
        if asteroid.is_offscreen(): gs["asteroids"].remove(asteroid)

    update_logic = gs.get("update_mode_logic")
    if update_logic: update_logic()

    if not gs["boxes"] and not gs["boss"]:
        gs["level"] += 1
        start_new_level()


# DRAWING FUNCTIONS
def draw_elements():
    w, h = pygame.display.get_surface().get_size()
    main_surface = screen
    if gs.get("screen_flipped"):
        main_surface = pygame.Surface((w, h))

    main_surface.fill(BLACK)
    state = gs["game_state"]

    if state in ["playing", "paused", "game_over", "victory"]:
        for star in gs["stars"]: star.draw(main_surface)
        if gs["boss"]: gs["boss"].draw(main_surface)
        for box in gs["boxes"]: box.draw(main_surface)
        if gs["power_up"]: gs["power_up"].draw(main_surface)
        for asteroid in gs["asteroids"]: asteroid.draw(main_surface)
        
        draw_logic = gs.get("draw_mode_extras")
        if draw_logic: draw_logic(main_surface)

        for p in gs["particles"]: p.draw(main_surface)
        if gs["hud_active"]: draw_hud(main_surface)

    elif state == "main_menu": draw_main_menu(main_surface)
    elif state == "difficulty_select": draw_difficulty_select_screen(main_surface)
    elif state == "stats": draw_stats_screen(main_surface)
    elif state == "shop": draw_shop_screen(main_surface)

    if state == "paused": draw_screen_overlay(main_surface, "Paused", pause_buttons)
    elif state == "game_over": draw_screen_overlay(main_surface, "Game Over", [reset_button])
    elif state == "victory": draw_screen_overlay(main_surface, "You Won?", [reset_button])

    if main_surface is not screen:
        screen.blit(pygame.transform.flip(main_surface, False, True), (0, 0))
    
    pygame.display.flip()

def draw_hud(surface):
    w, h = pygame.display.get_surface().get_size()
    surface.blit(font.render(f"Lives: {gs['lives']}", True, WHITE), (10, 10))
    surface.blit(font.render(f"Level: {gs['level']}", True, WHITE), (10, 40))
    surface.blit(font.render(f"Score: {int(gs['score'])}", True, WHITE), (10, 70))
    surface.blit(font.render(f"Dust: {gs['cosmic_dust']}", True, YELLOW), (10, 100))
    mode_text = f"Mode: {gs['game_mode_name'].replace('_', ' ').title()}"
    surface.blit(font.render(mode_text, True, STARLIGHT_CYAN), (w - font.size(mode_text)[0] - 10, 10))

def draw_main_menu(surface):
    w, h = pygame.display.get_surface().get_size()
    for star in gs["stars"]: star.draw(surface)
    title_surf = big_font.render("Box Tapper: Evolution", True, WHITE)
    surface.blit(title_surf, title_surf.get_rect(center=(w // 2, h // 4)))
    mouse_pos = pygame.mouse.get_pos()
    for btn in main_menu_buttons: btn.draw(surface, btn.is_clicked(mouse_pos))

def draw_difficulty_select_screen(surface):
    w, h = pygame.display.get_surface().get_size()
    for star in gs["stars"]: star.draw(surface)
    title_surf = big_font.render("Select Your Experience", True, WHITE)
    surface.blit(title_surf, title_surf.get_rect(center=(w // 2, 80)))
    mouse_pos = pygame.mouse.get_pos()
    for btn in mode_buttons: btn.draw(surface, btn.is_clicked(mouse_pos))

def draw_stats_screen(surface):
    w, h = pygame.display.get_surface().get_size()
    surface.fill(GALAXY_INDIGO)
    title_surf = big_font.render("Your Legacy of Tapping", True, WHITE)
    surface.blit(title_surf, title_surf.get_rect(center=(w // 2, 80)))
    stats = gs["stats"]
    lines = [ f"Total Boxes Tapped: {stats['total_boxes']}", f"Total Clicks: {stats['total_taps']}",
        f"Power-ups Collected: {stats['powerups_collected']}", f"Innocent Snails Harmed: {stats['snails_harmed']} (Monster!)" ]
    for i, line in enumerate(lines):
        line_surf = font.render(line, True, WHITE)
        surface.blit(line_surf, line_surf.get_rect(center=(w // 2, 200 + i * 50)))
    back_button.rect.center = (w // 2, h - 100)
    back_button.draw(surface, back_button.is_clicked(pygame.mouse.get_pos()))

def draw_shop_screen(surface):
    w, h = pygame.display.get_surface().get_size()
    surface.fill(GALAXY_INDIGO)
    title_surf = big_font.render("Upgrade Shop", True, WHITE)
    surface.blit(title_surf, title_surf.get_rect(center=(w // 2, 80)))
    back_button.rect.center = (w//2, h-100)
    back_button.draw(surface, back_button.is_clicked(pygame.mouse.get_pos()))

def draw_screen_overlay(surface, title_text, buttons):
    w, h = pygame.display.get_surface().get_size()
    overlay = pygame.Surface((w,h), pygame.SRCALPHA); overlay.fill((0, 0, 0, 200))
    surface.blit(overlay, (0, 0))
    text_surf = big_font.render(title_text, True, WHITE)
    surface.blit(text_surf, text_surf.get_rect(center=(w // 2, h // 4)))
    mouse_pos = pygame.mouse.get_pos()
    for btn in buttons: btn.draw(surface, btn.is_clicked(mouse_pos))


# EVENT HANDLING
def handle_input():
    global running
    for event in pygame.event.get():
        if event.type == pygame.QUIT: save_stats(); running = False
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: handle_mouse_click(event.pos)
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
            if gs.get("game_state") == "playing": gs["game_state"] = "paused"
            elif gs.get("game_state") == "paused": gs["game_state"] = "playing"

def handle_mouse_click(pos):
    if gs.get("stats"): gs["stats"]["total_taps"] += 1
    state = gs.get("game_state")
    if state == "main_menu":
        if main_menu_buttons[0].is_clicked(pos): gs["game_state"] = "difficulty_select"
        if main_menu_buttons[1].is_clicked(pos): gs["game_state"] = "stats"
        if main_menu_buttons[2].is_clicked(pos): save_stats(); global running; running = False
    elif state == "difficulty_select":
        for btn in mode_buttons:
            if btn.is_clicked(pos):
                if btn.text == "Back": gs["game_state"] = "main_menu"
                else: reset_game_state("casual", btn.text.lower().replace(" ", "_"))
    elif state == "stats" or state == "shop":
        if back_button.is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "paused":
        if pause_buttons[0].is_clicked(pos): gs["game_state"] = "playing"
        if pause_buttons[1].is_clicked(pos): gs["game_state"] = "shop"
        if pause_buttons[2].is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "game_over" or state == "victory":
        if reset_button.is_clicked(pos): gs["game_state"] = "main_menu"
    elif state == "playing": handle_gameplay_click(pos)

def handle_gameplay_click(pos):
    hit_something = False
    if gs.get("active_snail") and gs["active_snail"].rect.collidepoint(pos):
        gs["score"] -= 1000
        gs["stats"]["snails_harmed"] += 1
        gs["active_snail"] = None
        return
            
    if gs.get("power_up") and gs["power_up"].rect.collidepoint(pos):
        gs["stats"]["powerups_collected"] += 1
        if gs["power_up"].type == "nyan": gs["active_nyan"] = NyanCat(*pygame.display.get_surface().get_size())
        else: gs["power_up_active"] = gs["power_up"].type; gs["power_up_timer"] = time.time()
        gs["power_up"] = None
        return

    for box in gs["boxes"][:]:
        if box.rect.collidepoint(pos):
            if gs.get("stealth_mode_active"): box.fade_timer = time.time()
            damage_box(box)
            hit_something = True; break
            
    if not hit_something and gs.get("boss") and gs["boss"].rect.collidepoint(pos):
        gs["boss"].health -= (gs.get("equipped_tool").damage + gs["upgrades"]["damage"])
        if gs["boss"].health <= 0: gs["boss"] = None
        hit_something = True
    
    if not hit_something: gs["lives"] -= 1
    if gs["lives"] <= 0: save_high_scores(); gs["game_state"] = "game_over"

def damage_box(box):
    if box.special_type == "dramatic" and box.dramatic_death_timer == 0:
        box.start_dramatic_death()
        return

    box.health -= (gs.get("equipped_tool").damage + gs["upgrades"]["damage"])
    if box.health <= 0:
        if box in gs["boxes"]: gs["boxes"].remove(box)
        create_explosion(box.rect.centerx, box.rect.centery, box.color)
        gs["score"] += 500 if box.special_type == "rainbow" else 100
        gs["cosmic_dust"] += 1
        gs["stats"]["total_boxes"] += 1
        
        if box.special_type == "splitter":
            for _ in range(2):
                new_size = int(box.original_width * 0.6)
                new_box = Box(box.rect.centerx, box.rect.centery, new_size, new_size, COSMIC_MAGENTA, 1)
                new_box.speed *= 1.5
                gs["boxes"].append(new_box)


# MAIN GAME SETUP & LOOP
def create_buttons():
    w, h = pygame.display.get_surface().get_size()
    global main_menu_buttons, mode_buttons, pause_buttons, reset_button, back_button
    main_menu_buttons = [
        Button(w//2-150, h//2-80, 300, 60, "Play Game", AURORA_GREEN, WHITE, NEBULA_PURPLE),
        Button(w//2-150, h//2, 300, 60, "Stats", STARLIGHT_CYAN, WHITE, NEBULA_PURPLE),
        Button(w//2-150, h//2+80, 300, 60, "Quit", GRAY, WHITE, DARK_GRAY) ]
    mode_buttons = [
        Button(w//2-200, 200, 400, 50, "Classic", YELLOW, WHITE, NEBULA_PURPLE, "The standard, focused experience."),
        Button(w//2-200, 270, 400, 50, "Chaos Mode", RED, WHITE, NEBULA_PURPLE, "Pure mayhem. Not for the faint of heart."),
        Button(w//2-200, 340, 400, 50, "Stealth Mode", GALAXY_INDIGO, WHITE, NEBULA_PURPLE, "Boxes are nearly invisible."),
        Button(w//2-200, 410, 400, 50, "Boss Rush", COSMIC_MAGENTA, WHITE, NEBULA_PURPLE, "Face an endless stream of bosses."),
        Button(w//2-200, 550, 400, 50, "Back", GRAY, WHITE, DARK_GRAY) ]
    pause_buttons = [
        Button(w//2-150, h//2-100, 300, 60, "Resume", AURORA_GREEN, WHITE),
        Button(w//2-150, h//2, 300, 60, "Shop", STARLIGHT_CYAN, WHITE),
        Button(w//2-150, h//2+100, 300, 60, "Main Menu", GRAY, WHITE) ]
    reset_button = Button(w//2-150, h//2+100, 300, 60, "Back to Menu", GRAY, WHITE)
    back_button = Button(w//2-150, h-100, 300, 60, "Back", GRAY, WHITE, DARK_GRAY)

def reset_game_state(difficulty, mode):
    global gs
    save_stats()
    
    # Start with a fresh game state dictionary
    gs = {
        "difficulty": difficulty, "game_mode_name": mode,
        "level": 1, "score": 0, "score_multiplier": 1,
        "boxes": [], "asteroids": [], "boss": None, "power_up": None,
        "power_up_active": None, "power_up_timer": 0, "combo": 0, "combo_timer": 0,
        "hud_active": True, "debug_mode": False, "player_sequence": [],
        "particles": [], "cosmic_dust": 0, "screen_shake": 0, "level_clear_timer": 0,
        "active_nyan": None, "active_snail": None, "meteor_shower_timer": 0,
        "chaos_event_timer": 0, "screen_flipped": False, "gravity_reversed": False,
        "box_colors": [NEBULA_BLUE, NEBULA_PURPLE, GALAXY_INDIGO, STARLIGHT_CYAN, COSMIC_MAGENTA, AURORA_GREEN, RED],
    }
    
    # Carry over persistent data
    gs.update({
        "stars": persistent_data["stars"], "high_scores": persistent_data["high_scores"],
        "stats": persistent_data["stats"], "upgrades": persistent_data["upgrades"]
    })

    # Set up tools
    gs["basic_tapper"] = Tool("basic_tapper", 1, 1, 1, False)
    gs["cheat_tapper"] = Tool("cheat_tapper", 99, 999999, 1000, True)
    gs["equipped_tool"] = gs["basic_tapper"]
    
    # Set lives based on mode and upgrades
    lives = DIFFICULTY_SETTINGS.get(difficulty, {}).get("lives", 10)
    if mode == "boss_rush": lives = 3
    gs["max_lives"] = lives + gs["upgrades"]["lives"]
    gs["lives"] = gs["max_lives"]
    
    # CONFIGURE GAME MODE ONCE
    config = GAME_MODES.get(mode, GAME_MODES["classic"])
    for key, value in config.items():
        gs[key.replace("logic", "_logic")] = value # Ensure correct key names
    
    start_new_level()

# --- Main Execution ---
gs = setup_game_variables()
# Keep persistent data separate so it can be carried over
persistent_data = {
    "stars": gs["stars"], "high_scores": gs["high_scores"],
    "stats": gs["stats"], "upgrades": gs["upgrades"]
}
create_buttons()

running = True
while running:
    handle_input()
    if gs.get("game_state") == "playing":
        update_game_state()
    draw_elements()
    clock.tick(FPS)

pygame.quit()